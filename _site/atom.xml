<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>SA &amp; PE</title>
 <link href="http://frank0718.github.io/atom.xml" rel="self"/>
 <link href="http://frank0718.github.io"/>
 <updated>2015-12-18T12:18:27+08:00</updated>
 <id>http://frank0718.github.io</id>
 <author>
   <name>Frank</name>
   <email>blah@email.test</email>
 </author>

 
 <entry>
   <title>nginx best practice</title>
   <link href="http://frank0718.github.io/2015/12/18/nginx-best-practice"/>
   <updated>2015-12-18T00:00:00+08:00</updated>
   <id>http://frank0718.github.io/2015/12/18/nginx-best-practice</id>
   <content type="html">&lt;p&gt;++是否在工作中遇到过各种的nginx错误,导致服务不可用? 未注意到配置文件的细节问题,导致配置不生效? 遇到log中的提示,无法快速定位问题? 本文旨在提供一些方法或者思路,希望为大家解决各自的问题提供一些帮助.++&lt;/p&gt;

&lt;h2&gt;(1)debug&lt;/h2&gt;

&lt;p&gt;工欲善其事,必先利其器.
测试阶段找不到问题的原因时,开启error_log debug的开关,然后去看error_log的内容,你会收获很多.
&lt;code&gt;
error_log  /path/to/log debug;
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;(2) Nginx Error 413 Request Entity Too Large&lt;/h2&gt;

&lt;p&gt;由于
&lt;code&gt;
client_max_body_size 值默认是1m;
&lt;/code&gt;
所以在一些需要上传大文件或者请求的数据量比较大的场景下,需要适当的调整这个值.&lt;/p&gt;

&lt;h2&gt;(3)502/504错误&lt;/h2&gt;

&lt;p&gt;error_log一般会显示upstream timed out (110: Connection timed out)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;2014/08/14 10:23:15 [error] 19210#0: *104643398 upstream timed out (110: Connection timed out) while reading response header from upstream,
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明本层代理是ok的,要去找upstream指向的ip的http服务是否可用;http服务可用但是有ip或者port的限制,使用telnet ip port辅助查看结果&lt;/p&gt;

&lt;h2&gt;(4) 日志记录中HTTP状态码出现499错误&lt;/h2&gt;

&lt;p&gt;默认情况下
&lt;code&gt;
proxy_ignore_client_abort off，
&lt;/code&gt;
在请求过程中如果client主动关闭连接或者客户端网络断掉，那么 Nginx 会记录 499
如果使用了
&lt;code&gt;
proxy_ignore_client_abort on 
&lt;/code&gt;
不主动关闭客户端的连接;那么客户端主动断掉连接之后，Nginx 会等待后端处理完(或者超时)，然后记录后端返回的信息到日志。所以，如果后端返回 200， 就记录200 ；如果后端放回5XX ，那么就记录 5XX .如果超时(默认60s，可以用 proxy_read_timeout 设置)，Nginx 会主动断开连接，记录 504。&lt;/p&gt;

&lt;h2&gt;(5) Nginx 403 error: directory index of [folder] is forbidden&lt;/h2&gt;

&lt;p&gt;Error_log 如下
&lt;code&gt;
2014/08/21 11:59:26 [error] 4229#0: *38 directory index of &amp;quot;/home/xxxx&amp;quot; is forbidden, client: 127.0.0.1, server: abc.com, request: &amp;quot;HEAD / HTTP/1.1&amp;quot;, host: &amp;quot;abc.com&amp;quot;
&lt;/code&gt;
原因是访问这个域名的首页时由于没有配置首页的rewrite,nginx默认会去找目录中的index.html,所以解决方法有
&lt;code&gt;
a)  指定首页对应的文件如,rewrite ^/*$ /somefile break;
b)  在目录中建立index.html文件
c)  配置autoindex on;这样做用户在访问首页的时候会列出这个目录下的所有文件,强烈建议不要这么做,除非有特殊需求.
&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;(6)Permission denied&lt;/h2&gt;

&lt;p&gt;Error_log如下
&lt;code&gt;
2014/09/03 12:53:49 [error] 22402#0: *11399428976 open()  failed (13: Permission denied), client: 
&lt;/code&gt;
由于nginx默认用户是nobody(强烈建议不要用root用户);文件的权限如下
-rwxr-x--- 1 root root 160 Sep 3 12:44 allphoto.xml
Nobody没有read的权限,所以无法打开,当然就无法访问.改成644就可以了
-rw-r--r-- 1 root root 160 Sep 3 12:44 allphoto.xml&lt;/p&gt;

&lt;h2&gt;(7) rewrite 死循环&lt;/h2&gt;

&lt;p&gt;Error_log如下
&lt;code&gt;
2014/09/10 11:02:04 [error] 17989#0: *6 rewrite or internal redirection cycle while processing &amp;quot;/test.html&amp;quot;, client: 127.0.0.1, server: abc.com, request: &amp;quot;HEAD / HTTP/1.1&amp;quot;, host: &amp;quot;abc.com&amp;quot;
&lt;/code&gt;
提示rewrite或者内部重定向出现循环.解决办法:找到/test.html对应的配置,最后加上last或者break&lt;/p&gt;

&lt;h2&gt;(8) proxy_pass 注意点&lt;/h2&gt;

&lt;p&gt;proxy_pass” cannot have URI part in location given by regular expression, or inside named location, or inside “if” statement, or inside “limit_except” block …
eg:
&lt;code&gt;
location ~* \.(jsp|do)${
index index.jsp;
proxy_pass http://localhost:8080/shop_goods;
proxy_set_header X-Real-IP $remote_addr;
}
&lt;/code&gt;
当location中配置的有正则表达式,或在命名location中,或在if语句,或在limit_except 块中,proxy_pass 不能有URI的部分,只能是proxy_pass &lt;a href=&quot;http://ip:port%E7%9A%84%E5%BD%A2%E5%BC%8F&quot;&gt;http://ip:port的形式&lt;/a&gt;.&lt;/p&gt;

&lt;h2&gt;(9) nginx配置chunked开关&lt;/h2&gt;

&lt;p&gt;有时候用curl –I 可以看到reponse的header里面会有
&lt;code&gt;Transfer-Encoding:chunked&lt;/code&gt;
这一项,它表明采用chunked编码方式来进行报文体的传输。chunked编码是HTTP/1.1 RFC里定义的一种编码方式。
&lt;code&gt;
chunked编码的基本原理是将大块数据分解成多块小数据，每块都可以自指定长度。这样就能更快的让页面呈现出来,数据被截成许多小片段，浏览器分段解析。但是在一些场景中,要避免分块传输,client希望请求的数据一次性传输完毕,就需要设置
&lt;/code&gt;
&lt;code&gt;chunked_transfer_encoding off;&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;(10)关于正则&lt;/h2&gt;

&lt;p&gt;nginx location/if 中的正则表达式子模式(subpatterns)与逆向引用(Back references)
比如
&lt;code&gt;
location ~ ^/somedir/((abc)|(.*))/$ 
&lt;/code&gt;
那么$1=abc.&lt;em&gt;,$2=abc,$3=.&lt;/em&gt;,它们的序号是由左括号的顺序决定的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>test highlight</title>
   <link href="http://frank0718.github.io/2015/12/16/test-highlight"/>
   <updated>2015-12-16T00:00:00+08:00</updated>
   <id>http://frank0718.github.io/2015/12/16/test-highlight</id>
   <content type="html">&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;  &lt;span class=&quot;s&quot;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
</content>
 </entry>
 
 <entry>
   <title>fabric best practice</title>
   <link href="http://frank0718.github.io/2015/12/16/fabric-best-practice"/>
   <updated>2015-12-16T00:00:00+08:00</updated>
   <id>http://frank0718.github.io/2015/12/16/fabric-best-practice</id>
   <content type="html">&lt;h1&gt;Fabric--运维自动化利器&lt;/h1&gt;

&lt;h2&gt;(一)介绍&lt;/h2&gt;

&lt;p&gt;fabric是一个开源的,使用python作为源码的自动化运维工具.它具有以下优点:
1. 无需server端配置,只需client和server有ssh连接.
2. 相对于saltstack,ansible更轻量级.使用安装方便.
3. 配置文件使用python语言,源码为python,运维工程师操作起来学习成本较小.出现问题可直接翻阅源码.
4. 可自定义python函数,完成自定的自动化功能.相对于ansible的模块化,显得比较自由.
...&lt;/p&gt;

&lt;h2&gt;(二)安装&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;推荐 pip install fabric&lt;/li&gt;
&lt;li&gt;不推荐 sudo apt-get install fabric  版本会比较旧&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;(三)使用&lt;/h2&gt;

&lt;p&gt;安装完之后会有一个fab 命令来执行,默认使用pwd下面的fabfile.py 作为配置文件.也可以使用 fab -f somefile.py 来作为配置文件.具体的命令行参数可以通过
fab -h来查看&lt;/p&gt;

&lt;p&gt;工具的核心是其配置文件,我默认就使用fabfile.py作为文件名.下面就里面一些配置做下简要介绍.&lt;/p&gt;

&lt;h3&gt;(1)重要api&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;fabric.api&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;导入&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fabric&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;包中的核心&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;api&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;函数&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;大概包括以下&lt;/span&gt;


&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;abort          fastprint      lcd            parallel       put            remote_tunnel  runs_once      show           warn_only      &lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;cd             get            local          path           puts           require        serial         sudo           with_settings  &lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;env            hide           open_shell     prefix         quiet          roles          settings       task           &lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;execute        hosts          output         prompt         reboot         run            shell_env      warn   &lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;open_shell&lt;/span&gt;
&lt;span class=&quot;sd&quot;&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中比较重要和常用的有
```
lcd:切换本地目录
parallel:多个server并行执行任务
put:上传本地文件到server
cd:切换server的目录
get:下载server的文件到本地
local:执行本地的命令
sudo:在server上执行sudo命令
env:设置本地的环境变量.
roles:选定一组role
execute:绑定多个方法
hosts:选定一组server
run:执行具体的任务.&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;###(2)输出着色
from fabric.colors import * 导入fabric包中的颜色函数,用来对输出进行着色.

###(3)设定环境变量
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;env.user = &amp;#39;bjzhangfeng&amp;#39;#指定remote server中的用户
env.port  = &amp;#39;22&amp;#39; #指定remote server ssh的port
这个设置是全局的,在具体的函数里面可以对其重新设定来覆盖这个全局设置,比如某一台server 的ssh port 不为22.&lt;/p&gt;

&lt;p&gt;env.roledefs = {  #设定一组角色, 比如abc 代表一组server,xyz代表一组server
    &amp;#39;abc&amp;#39;:[
    &amp;#39;1.1.1.1&amp;#39;,
    &amp;#39;1.1.1.2&amp;#39;,
    &amp;#39;1.1.1.3&amp;#39;,
    ],
  &amp;#39;xyz&amp;#39;:[
    &amp;#39;2.1.1.1&amp;#39;,
    &amp;#39;2.1.1.2&amp;#39;,
    &amp;#39;2.1.1.3&amp;#39;,
    ],
}
```&lt;/p&gt;

&lt;h3&gt;(4)定义任务&lt;/h3&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;(a):run方法
def w():
    run(&amp;#39;w&amp;#39;)
通过定义函数来执行具体的任务,run指在server上 以 env.user用户执行w命令.
fab -R abc w
在abc这组server上执行w
fab -H 1.1.1.1 w
在单台server上执行 w
fab -H 1.1.1.1,1.1.1.2 w
在这两台机器上执行w

(b)local 方法
def w():
   local(&amp;#39;w&amp;#39;)
fab w
在本地执行w命令

(c)sudo 方法
def ss():
  sudo(&amp;#39;ss -s&amp;#39;)
fab -R abc ss
在abc组以sudo的方式执行ss -s

(d)roles/hosts装饰器
@roles(&amp;#39;abc&amp;#39;)
def w():
    run(&amp;#39;w&amp;#39;)

fab w
绑定w方法到abc服务器角色. 对于某个方法只适用于某个role的情形下,非常好用.

(e)parallel装饰器.
@parallel
@roles(&amp;#39;abc&amp;#39;)
def w():
    run(&amp;#39;w&amp;#39;)
fab w
以并行的方式在abc一组server上,执行w命令.由于fabric默认是串行的执行任务.在server比较多的情况下,并行执行可以节省时间.

(f)put方法/get 方法
def put():
   put(&amp;#39;~/locafile&amp;#39;,&amp;#39;~/&amp;#39;)
fab -R abc put
把本地文件put到server端

(g) 对方法传参数,
def curlc(url):
    while True:
        local(&amp;#39;curl -I %s ; sleep 1&amp;#39; % (url,))
fab curlc:http://www.163.com
对于多个参数用逗号分隔
def curl(url,ip=&amp;#39;2.2.2.2&amp;#39;):
    while True:
        local(&amp;#39;curl -I %s -x %s:80; sleep 1&amp;#39; % (url,ip))
fab curl:http://www.163.com,1.1.1.1

(h)execute方法
def ab(url):
    execute(a,url)
    execute(b,url)
fab -R abc ab
当需要合并执行多个方法的时候可以用这种方式,

(i)更换user,port
def whoami():
    env.user = &amp;#39;fabric&amp;#39;
    run(&amp;#39;whoami&amp;#39;)
fab -R xyz whoami
在xyz上以fabric用户执行

 def ew():
    env.port = &amp;#39;8822&amp;#39;
    run(&amp;#39;w&amp;#39;)
fab -R xyz w
使用8822端口登陆ssh执行命令
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;(四)总结&lt;/h2&gt;

&lt;p&gt;本文简单介绍了fabric工具,并展示了一些基本的使用方法.有需求的同学可以深入研究,以提高工作效率.&lt;/p&gt;

&lt;h2&gt;(五)参考文档&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.fabfile.org/en/1.10/index.html&quot;&gt;http://docs.fabfile.org/en/1.10/index.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Github blog</title>
   <link href="http://frank0718.github.io/2015/12/14/github-blog"/>
   <updated>2015-12-14T00:00:00+08:00</updated>
   <id>http://frank0718.github.io/2015/12/14/github-blog</id>
   <content type="html">&lt;h1&gt;搭建github博客&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;在国内的环境装软件真是TM的艰辛&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;先列出环境 Ubuntu12.04 i386&lt;/p&gt;

&lt;h2&gt;(1) 安装rvm&lt;/h2&gt;

&lt;p&gt;按照google搜出来的教程.
curl -L &lt;a href=&quot;https://get.rvm.io&quot;&gt;https://get.rvm.io&lt;/a&gt; | bash -s stable 根本没反应好不好,
只好去vps上把&lt;a href=&quot;https://get.rvm.io%E4%BB%A3%E7%A0%81%E6%8B%BF%E5%88%B0&quot;&gt;https://get.rvm.io代码拿到&lt;/a&gt; push到git 上,或者copy到本地. 执行
bash rvm.sh stable &lt;/p&gt;

&lt;h2&gt;(2) 保证github 或者bitbucket 可用.&lt;/h2&gt;

&lt;p&gt;rvm.sh 要从github 或者 bitbucket.org取代码.&lt;/p&gt;

&lt;h2&gt;(3)配置 /etc/profile 让系统找到rvm的位置.&lt;/h2&gt;

&lt;p&gt;rvm安装完成后, 
默认rvm 装在 /usr/local/rvm, 
编辑/etc/profile, 最后加入
export PATH=/usr/local/../bin:$PATH
安装完成 
rvm -v
rvm 1.26.11&lt;/p&gt;

&lt;h2&gt;(4)配置ubuntu的源&lt;/h2&gt;

&lt;p&gt;使用souhu的12.04的源. 
apt-get update  , 
因为默认的源 没法更新libsqlite ,  坑爹.  使用搜狐的就可以了.&lt;/p&gt;

&lt;p&gt;rvm requirements 查看依赖,并自动解决依赖.
执行之后下面的都装上了,为安装ruby做准备,又离成功近了唉
apt-get --no-install-recommends --yes install gawk libyaml-dev libsqlite3-dev sqlite3 libgdbm-dev libtool bison&lt;/p&gt;

&lt;h2&gt;(5)第一次安装ruby (fail)&lt;/h2&gt;

&lt;p&gt;rvm install 2.0.0
No binary rubies available for: ubuntu/12.04/i386/ruby-2.0.0-p643.
还要编译安装.
....中间省略
Installing Ruby from source to: /usr/local/rvm/rubies/ruby-2.0.0-p643, this may take a while depending on your cpu(s)...&lt;/p&gt;

&lt;p&gt;ruby-2.0.0-p643 - #extracting ruby-2.0.0-p643 to /usr/local/rvm/src/ruby-2.0.0-p643....
ruby-2.0.0-p643 - #configuring..................................................
ruby-2.0.0-p643 - #post-configuration..
ruby-2.0.0-p643 - #compiling.............................................................................
ruby-2.0.0-p643 - #installing..............................
ruby-2.0.0-p643 - #making binaries executable..
ruby-2.0.0-p643 - #downloading rubygems-2.4.8  卡住不动了
好吧.ctrl c取消了安装过程,downloading是在走不动啊 &lt;/p&gt;

&lt;h2&gt;(6)第一次配置ruby (fail)&lt;/h2&gt;

&lt;p&gt;rvm 2.0.0 --default
报错
Gemset &amp;#39;&amp;#39; does not exist, &amp;#39;rvm ruby-2.0.0-p643 do rvm gemset create &amp;#39; first, or append &amp;#39;--create&amp;#39;.
看来ruby 和gem是需要同时安装的.
具体怎么单独安装gem , 查不到...&lt;/p&gt;

&lt;p&gt;痛定思痛. 再去google. &lt;/p&gt;

&lt;h2&gt;(7)第二次安装ruby (success)&lt;/h2&gt;

&lt;p&gt;由于rvm安装ruby时,使用的是国外的源, 速度不忍直视.&lt;/p&gt;

&lt;p&gt;修改rvm的源 为taobao的 
$ sed -i -E &amp;#39;s!https?://cache.ruby-lang.org/pub/ruby!&lt;a href=&quot;https://ruby.taobao.org/mirrors/ruby!&amp;#x27;$rvm_path/config/db&quot;&gt;https://ruby.taobao.org/mirrors/ruby!&amp;#39;$rvm_path/config/db&lt;/a&gt;
这里的rvmpath就是/usr/local/rvm/目录.&lt;/p&gt;

&lt;p&gt;rvm install 2.2.0&lt;/p&gt;

&lt;p&gt;完成. 速度还挺快. &lt;/p&gt;

&lt;p&gt;当做默认的rvm版本
 rvm use 2.2.0 --default
Using /usr/local/rvm/gems/ruby-2.2.0&lt;/p&gt;

&lt;p&gt;查询已经安装的ruby
rvm list
卸载一个已安装版本
rvm remove 2.0.0 &lt;/p&gt;

&lt;p&gt;ruby -v
ruby 2.2.0p0 (2014-12-25 revision 49005) [i686-linux]&lt;/p&gt;

&lt;p&gt;查看gem的版本
 gem -v
2.4.8&lt;/p&gt;

&lt;p&gt;走到这一步,泪流满面,感谢方校长....&lt;/p&gt;

&lt;h2&gt;(8) 配置gem源&lt;/h2&gt;

&lt;p&gt;速度问题,必须修改 gem的源 为淘宝的 . 
$ gem sources --add &lt;a href=&quot;https://ruby.taobao.org/&quot;&gt;https://ruby.taobao.org/&lt;/a&gt; --remove &lt;a href=&quot;https://rubygems.org/&quot;&gt;https://rubygems.org/&lt;/a&gt;
$ gem sources -l
*** CURRENT SOURCES ***&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://ruby.taobao.org&quot;&gt;https://ruby.taobao.org&lt;/a&gt;
请确保只有 ruby.taobao.org&lt;/p&gt;

&lt;p&gt;有选择的安装rails
$ gem install rails
&lt;a href=&quot;https://ruby.taobao.org/&quot;&gt;https://ruby.taobao.org/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;(9)安装 jeklly (终于来了)&lt;/h2&gt;

&lt;p&gt;gem install jekyll -V&lt;/p&gt;

&lt;p&gt;第一次装报ssl的错误, 查了一大堆 也没看出来咋搞. 
具体参考:
&lt;a href=&quot;https://gist.github.com/luislavena/f064211759ee0f806c88&quot;&gt;https://gist.github.com/luislavena/f064211759ee0f806c88&lt;/a&gt;
&lt;a href=&quot;https://raw.githubusercontent.com/rubygems/rubygems/master/lib/rubygems/ssl_certs/AddTrustExternalCARoot-2048.pem&quot;&gt;https://raw.githubusercontent.com/rubygems/rubygems/master/lib/rubygems/ssl_certs/AddTrustExternalCARoot-2048.pem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blacktha.com/2015/07/06/tech/Ruby/&quot;&gt;http://blacktha.com/2015/07/06/tech/Ruby/&lt;/a&gt;
&lt;a href=&quot;http://yunkus.com/article/ziyuan/287.html&quot;&gt;http://yunkus.com/article/ziyuan/287.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;等了一会再装就ok了(网络问题?). &lt;/p&gt;

&lt;p&gt;jekyll -v
jekyll 3.0.1&lt;/p&gt;

&lt;h2&gt;(10)  搭建博客&lt;/h2&gt;

&lt;p&gt;前提:
按照github的提示一步步建立自己的repo
然后参考了一个博客,使用现成的模板&lt;/p&gt;

&lt;p&gt;git clone &lt;a href=&quot;https://github.com/plusjade/jekyll-bootstrap.git&quot;&gt;https://github.com/plusjade/jekyll-bootstrap.git&lt;/a&gt;
jekyll server
启动一个本地的server . &lt;/p&gt;

&lt;p&gt;创建一篇post
rake post title=&amp;quot;Hello World&amp;quot;
rake page name=&amp;quot;about.md&amp;quot;&lt;/p&gt;

&lt;p&gt;然后可以把这个目录的内容cp到自己的github项目里 , 
需要注意
修改文件：&lt;em&gt;config.yml，设置production_url
~ vi _config.yml
production&lt;/em&gt;url : &lt;a href=&quot;http://frank0718.github.io&quot;&gt;http://frank0718.github.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;git add -all
git commit -m &amp;quot;add &amp;quot;
git  push  origin master
然后就能看到博客了 &lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Hello World</title>
   <link href="http://frank0718.github.io/2015/12/09/hello-world"/>
   <updated>2015-12-09T00:00:00+08:00</updated>
   <id>http://frank0718.github.io/2015/12/09/hello-world</id>
   <content type="html">&lt;h2&gt;开始&lt;/h2&gt;
</content>
 </entry>
 
 
</feed>
